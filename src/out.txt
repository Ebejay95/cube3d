
#include "../../include/cub3d.h"

void	calculate_map_coordinates(t_game *game, t_render_data *d)
{
	d->rot_x = -(d->y - (MF / 2)) * d->cosa + (d->x - (MF / 2)) * d->sina;
	d->rot_y = (d->y - (MF / 2)) * d->sina + (d->x - (MF / 2)) * d->cosa;
	d->map_x = (int)((game->player->x / CELL) + (d->rot_x / (float)MCELL));
	d->map_y = (int)((game->player->y / CELL) + (d->rot_y / (float)MCELL));
}

int	is_valid_map_position(t_game *game, t_render_data *d)
{
	if (d->map_x >= 0 && d->map_x < game->map->width && d->map_y >= 0
		&& d->map_y < game->map->height)
		return (1);
	return (0);
}

void	mrender_rotmap(t_game *game, float cosa, float sina)
{
	t_render_data	data;
	char			map_content;

	data.cosa = cosa;
	data.sina = sina;
	data.y = FRAME_THICKNESS;
	while (data.y < MF - FRAME_THICKNESS)
	{
		data.x = FRAME_THICKNESS;
		while (data.x < MF - FRAME_THICKNESS)
		{
			calculate_map_coordinates(game, &data);
			if (is_valid_map_position(game, &data))
			{
				map_content = game->map->content[data.map_y][data.map_x];
				if (map_content == '1')
					mlx_put_pixel(game->surface, data.x, data.y, WALL_COLOR);
				else if (ft_strchr("NEWS0", map_content))
					mlx_put_pixel(game->surface, data.x, data.y, ROOM_COLOR);
			}
			data.x++;
		}
		data.y++;
	}
}

void	mdraw_player(t_game *game)
{
	int	x;
	int	y;
	int	px;
	int	py;

	y = -2;
	while (y <= 2)
	{
		x = -2;
		while (x <= 2)
		{
			px = (MF / 2) + x;
			py = (MF / 2) + y;
			if (px >= FRAME_THICKNESS && px < MF - FRAME_THICKNESS
				&& py >= FRAME_THICKNESS && py < MF - FRAME_THICKNESS)
			{
				mlx_put_pixel(game->surface, px, py, PLAYER_COLOR);
			}
			x++;
		}
		y++;
	}
}

void	render_minimap(t_game *game)
{
	float	cosa;
	float	sina;
	int		x;
	int		y;

	cosa = cos(-game->player->angle);
	sina = sin(-game->player->angle);
	y = 0;
	while (y < MF)
	{
		x = 0;
		while (x < MF)
		{
			if (x < FRAME_THICKNESS || x >= MF - FRAME_THICKNESS
				|| y < FRAME_THICKNESS || y >= MF - FRAME_THICKNESS)
				mlx_put_pixel(game->surface, x, y, FRAME_COLOR);
			else
				mlx_put_pixel(game->surface, x, y, WALL_COLOR);
			x++;
		}
		y++;
	}
	mrender_rotmap(game, cosa, sina);
	mrender_rotmap(game, cosa, sina);
	mdraw_player(game);
}


#include "../include/cub3d.h"

void	calc_delta(t_game *game, char operator)
{
	float	angle_incr;

	angle_incr = 0.06;
	if (operator == '+')
		game->player->angle = angle_check(game->player->angle + angle_incr);
	else if (operator == '-')
		game->player->angle = angle_check(game->player->angle - angle_incr);
	game->deltax = cos(game->player->angle);
	game->deltay = sin(game->player->angle);
	game->angle = game->player->angle;
}

void	key_hook(mlx_key_data_t keydata, void *param)
{
	t_game	*game;
	bool	is_pressed;

	game = (t_game *)param;
	if (keydata.key == MLX_KEY_ESCAPE && keydata.action == MLX_PRESS)
		mlx_close_window(game->mlx);
	is_pressed = (keydata.action == MLX_PRESS || keydata.action == MLX_REPEAT);
	if (keydata.key == MLX_KEY_W)
		game->key_states.w_pressed = is_pressed;
	else if (keydata.key == MLX_KEY_S)
		game->key_states.s_pressed = is_pressed;
	else if (keydata.key == MLX_KEY_A)
		game->key_states.a_pressed = is_pressed;
	else if (keydata.key == MLX_KEY_D)
		game->key_states.d_pressed = is_pressed;
	else if (keydata.key == MLX_KEY_LEFT)
		game->key_states.left_pressed = is_pressed;
	else if (keydata.key == MLX_KEY_RIGHT)
		game->key_states.right_pressed = is_pressed;
}

void	update_game_state(void *param)
{
	t_game	*game;

	game = (t_game *)param;
	if (game->key_states.w_pressed)
		check_move_up(game);
	if (game->key_states.s_pressed)
		check_move_down(game);
	if (game->key_states.a_pressed)
		check_move_left(game);
	if (game->key_states.d_pressed)
		check_move_right(game);
	if (game->key_states.left_pressed)
		calc_delta(game, '-');
	if (game->key_states.right_pressed)
		calc_delta(game, '+');
	ft_surface(game);
	ray_calculation(game);
	render_minimap(game);
}

void	start_game(t_game *game)
{
	if (game)
	{
		mlx_set_setting(MLX_STRETCH_IMAGE, 1);
		mlx_key_hook(game->mlx, &key_hook, game);
		mlx_loop_hook(game->mlx, &update_game_state, game);
		mlx_loop(game->mlx);
		mlx_terminate(game->mlx);
	}
}


#include "../include/cub3d.h"

void	check_leaks(void)
{
	system("leaks cub3d");
}

int	main(int argc, char **argv)
{
	t_game	game;

	atexit(check_leaks);
	ft_initialize(&game, argc, argv);
	if (!game.map)
	{
		call_exit(&game);
		return (1);
	}
	if (!ft_init_window(&game))
		return (ft_printf(RED"Error init window\n"D), call_exit(&game), 0);
	start_game(&game);
	call_exit(&game);
	return (0);
}


#include "../include/cub3d.h"

void	i_like_to_move_it_move_it(t_game *game, float new_x, float new_y)
{
	game->player->x = new_x;
	game->player->y = new_y;
}

int	check_move_up(t_game *game)
{
	float	new_x;
	float	new_y;

	new_x = game->player->x + cos(game->player->angle) * PLYR_STEP;
	new_y = game->player->y + sin(game->player->angle) * PLYR_STEP;
	check_collision(game, &new_x, &new_y);
	i_like_to_move_it_move_it(game, new_x, new_y);
	return (1);
}

int	check_move_down(t_game *game)
{
	float	new_x;
	float	new_y;

	new_x = game->player->x - cos(game->player->angle) * PLYR_STEP;
	new_y = game->player->y - sin(game->player->angle) * PLYR_STEP;
	check_collision(game, &new_x, &new_y);
	i_like_to_move_it_move_it(game, new_x, new_y);
	return (1);
}

int	check_move_left(t_game *game)
{
	float	new_x;
	float	new_y;

	new_x = game->player->x + sin(game->player->angle) * PLYR_STEP;
	new_y = game->player->y - cos(game->player->angle) * PLYR_STEP;
	check_collision(game, &new_x, &new_y);
	i_like_to_move_it_move_it(game, new_x, new_y);
	return (1);
}

int	check_move_right(t_game *game)
{
	float	new_x;
	float	new_y;

	new_x = game->player->x - sin(game->player->angle) * PLYR_STEP;
	new_y = game->player->y + cos(game->player->angle) * PLYR_STEP;
	check_collision(game, &new_x, &new_y);
	i_like_to_move_it_move_it(game, new_x, new_y);
	return (1);
}


#include "../../include/cub3d.h"

void	check_the_spot_down(t_map *map, int ydex, int xdex, int *err)
{
	int	y;

	y = ydex;
	while (y < map->height)
	{
		if (map->content[y][xdex] == '1')
			return ;
		y++;
	}
	(*err)++;
	ft_fprintf(2, RED"The map content is not closed - detected here:\n"D);
	print_map_error(map, ydex, xdex);
}

void	check_the_spot_up(t_map *map, int ydex, int xdex, int *err)
{
	int	y;

	y = ydex;
	while (y >= 0)
	{
		if (map->content[y][xdex] == '1')
			return ;
		y--;
	}
	(*err)++;
	ft_fprintf(2, RED"The map content is not closed - detected here:\n"D);
	print_map_error(map, ydex, xdex);
}

void	check_the_spot_left(t_map *map, int ydex, int xdex, int *err)
{
	int	x;

	x = xdex;
	while (x >= 0)
	{
		if (map->content[ydex][x] == '1')
			return ;
		x--;
	}
	(*err)++;
	ft_fprintf(2, RED"The map content is not closed - detected here:\n"D);
	print_map_error(map, ydex, xdex);
}

void	check_the_spot_right(t_map *map, int ydex, int xdex, int *err)
{
	int	x;

	x = xdex;
	while (x < map->width)
	{
		if (map->content[ydex][x] == '1')
			return ;
		x++;
	}
	(*err)++;
	ft_fprintf(2, RED"The map content is not closed - detected here:\n"D);
	print_map_error(map, ydex, xdex);
}

void	check_the_spot(t_map *map, int ydex, int xdex, int *err)
{
	if (!(*err))
		check_the_spot_up(map, ydex, xdex, err);
	if (!(*err))
		check_the_spot_down(map, ydex, xdex, err);
	if (!(*err))
		check_the_spot_left(map, ydex, xdex, err);
	if (!(*err))
		check_the_spot_right(map, ydex, xdex, err);
}


#include "../../include/cub3d.h"

void	init_flood(t_map *map)
{
	int	y;
	int	x;

	y = 0;
	while (y < map->height)
	{
		x = 0;
		while (x < map->width)
		{
			if (map->content[y][x] == '0')
				map->content[y][x] = 'X';
			x++;
		}
		y++;
	}
}

void	flood_one(char *ref, int *check, char *work)
{
	if (ft_strchr(ref, *work))
	{
		*work = 'X';
		(*check)--;
	}
}

int	check_xy_nexts(t_map *map, int ydex, int xdex)
{
	int		check;
	char	*ref;

	check = 0;
	ref = ft_strdup("0 ");
	if (ydex != 0)
		flood_one(ref, &check, &map->content[ydex - 1][xdex]);
	if (xdex != 0)
		flood_one(ref, &check, &map->content[ydex][xdex - 1]);
	if (ydex != (map->height - 1))
		flood_one(ref, &check, &map->content[ydex + 1][xdex]);
	if (xdex != (map->width - 1))
		flood_one(ref, &check, &map->content[ydex][xdex + 1]);
	free(ref);
	return (check);
}

void	flood(t_map *map)
{
	int		check;
	int		xdex;
	int		ydex;

	check = -1;
	while (check < 0)
	{
		check = 0;
		ydex = 0;
		while (ydex < map->height)
		{
			xdex = 0;
			while (xdex < map->width)
			{
				if ('X' == map->content[ydex][xdex])
					check = check + check_xy_nexts(map, ydex, xdex);
				xdex++;
			}
			ydex++;
		}
	}
}


#include "../../include/cub3d.h"

void	set_spawn_point(t_map *map, int x, int y)
{
	map->spawn = map->content[y][x];
	map->spawn_x = x;
	map->spawn_y = y;
	map->content[y][x] = '0';
}

void	handle_multiple_spawns(t_map *map, int y, int x, int *err)
{
	(*err)++;
	ft_fprintf(2, RED"multiple spawns detected:\n"D);
	print_map_error(map, y, x);
}

void	check_spawn_cell(t_map *map, int y, int x, int *err)
{
	if (ft_strchr("NEWS", map->content[y][x]) != NULL)
	{
		if (map->spawn == '-')
			set_spawn_point(map, x, y);
		else
			handle_multiple_spawns(map, y, x, err);
	}
}

void	handle_no_spawns(t_map *map, int *err)
{
	(*err)++;
	ft_fprintf(2, RED"no spawns detected:\n"D);
	print_map_error(map, 0, 0);
}

void	check_spawn(t_map *map, int *err)
{
	int	y;
	int	x;

	y = 0;
	while (y < map->height && !(*err))
	{
		x = 0;
		while (x < map->width)
		{
			check_spawn_cell(map, y, x, err);
			x++;
		}
		y++;
	}
	if (map->spawn == '-' && !(*err))
		handle_no_spawns(map, err);
}


#include "../../include/cub3d.h"

void	check_chars(t_map *map, int *err)
{
	int	y;

	y = 0;
	while (y < map->height && !(*err))
	{
		if (map->width != (int)ft_strspn(map->content[y], MAP_CNT_CHARS))
		{
			(*err)++;
			ft_fprintf(2, RED"Invalid char in map:\n"D);
			print_map_error(map, y, ft_strspn(map->content[y], MAP_CNT_CHARS));
		}
		y++;
	}
}

int	has_defined_insides(t_map *map)
{
	int	y;
	int	x;

	y = 0;
	while (y < map->height)
	{
		x = 0;
		while (x < map->width)
		{
			if (map->content[y][x] == '0')
				return (1);
			x++;
		}
		y++;
	}
	return (0);
}

void	map_validation(t_map *map, int *err)
{
	int	y;
	int	x;

	check_chars(map, err);
	check_spawn(map, err);
	while (has_defined_insides(map) && !(*err))
	{
		init_flood(map);
		flood(map);
	}
	y = 0;
	while (y < map->height && !(*err))
	{
		x = 0;
		while (x < map->width && !(*err))
		{
			if (map->content[y][x] == 'X')
				check_the_spot(map, y, x, err);
			x++;
		}
		y++;
	}
}

void	clear_validation(t_map *map)
{
	int	y;
	int	x;

	y = 0;
	while (y < map->height)
	{
		x = 0;
		while (x < map->width)
		{
			if (y == map->spawn_y && x == map->spawn_x)
				map->content[y][x] = map->spawn;
			if (map->content[y][x] == 'X')
				map->content[y][x] = '0';
			x++;
		}
		y++;
	}
}

void	get_map_content(int fd, int *err, t_game *game)
{
	char	*line;
	char	*content;
	char	*temp;

	content = ft_strdup("");
	line = get_next_line(fd);
	while (line != NULL && !(*err))
	{
		temp = ft_strjoin(content, line);
		free(content);
		content = temp;
		free(line);
		line = get_next_line(fd);
	}
	if (ft_strlen(content) != (size_t)ft_strspn(content, MAP_CNT_CHARS))
	{
		(*err)++;
		ft_fprintf(2, RED"Invalid char in map\n"D);
	}
	parse_map_array(game->map, map_split(content));
	map_validation(game->map, err);
	clear_validation(game->map);
	free(content);
	free(line);
	line = NULL;
}


#include "../../include/cub3d.h"

char	*get_textr_path(char *line, size_t size, int *err)
{
	size_t	i;
	size_t	j;
	size_t	new_size;
	char	*path;

	i = 0;
	while (line[i] && i < size)
		i++;
	if (i < size)
		(*err)++;
	new_size = i;
	while (line[new_size] && line[new_size] != '\n')
		new_size++;
	new_size = new_size - i;
	path = malloc(sizeof(char) * (new_size + 1));
	if (!path)
		return ((*err)++, NULL);
	j = 0;
	while (j < new_size)
	{
		path[j] = line[j + i];
		j++;
	}
	path[new_size] = '\0';
	return (path);
}

char	*trim_whitespace_and_newline(char *str)
{
	char	*end;

	while (*str && (*str == ' ' || *str == '\t'))
		str++;
	end = str + ft_strlen(str) - 1;
	while (end > str && (*end == ' ' || *end == '\t' || *end == '\n'))
		end--;
	*(end + 1) = '\0';
	return (str);
}

uint32_t	create_color(int r, int g, int b)
{
	return (0xFF | (b << 8) | (g << 16) | (r << 24));
}

int	validate_color_component(char *component)
{
	int	i;
	int	value;

	i = 0;
	while (component[i])
	{
		if (!ft_isdigit(component[i]))
			return (0);
		i++;
	}
	value = ft_atoi(component);
	if (value < 0 || value > 255)
		return (0);
	return (1);
}

int	validate_color_split(char **split)
{
	if (!split || !split[0] || !split[1] || !split[2] || split[3])
	{
		return (0);
	}
	if (!validate_color_component(split[0])
		|| !validate_color_component(split[1])
		|| !validate_color_component(split[2]))
	{
		return (0);
	}
	return (1);
}


#include "../../include/cub3d.h"

char	**split_and_trim(char *str, char s)
{
	char	**split;
	char	*tmp_trm;
	int		i;

	i = 0;
	split = ft_split(str, s);
	while (split && split[i])
	{
		tmp_trm = ft_strtrim(split[i], " ");
		free(split[i]);
		split[i] = tmp_trm;
		i++;
	}
	return (split);
}

uint32_t	parse_color(char *str, int start, int *err)
{
	char		**split;
	int			r;
	int			g;
	int			b;
	uint32_t	color;

	str = trim_whitespace_and_newline(str + start);
	split = split_and_trim(str, ',');
	if (!validate_color_split(split))
	{
		ft_array_free(split);
		*err = 1;
		return (0);
	}
	r = ft_atoi(split[0]);
	g = ft_atoi(split[1]);
	b = ft_atoi(split[2]);
	color = create_color(r, g, b);
	ft_array_free(split);
	return (color);
}

void	set_color_meta(int *err, char *line, t_game *g, char kind)
{
	uint32_t	color;

	color = parse_color(line, 1, err);
	if (!(*err))
	{
		if (kind == 'f')
		{
			g->map->floor = color;
			g->map->floor_set = 1;
		}
		else if (kind == 'c')
		{
			g->map->ceiling = color;
			g->map->ceiling_set = 1;
		}
	}
	if (*err)
	{
		ft_fprintf(2, RED"Error loading color in map meta definition: ");
		ft_fprintf(2, "%s\n"D, line);
	}
}

void	set_textr_meta(int *err, char *line, t_game *g, char ornttn)
{
	char	*path;
	int		fd;
	char	*tmp_path;

	tmp_path = get_textr_path(line, 3, err);
	path = ft_strtrim(tmp_path, " ");
	fd = open(path, O_RDONLY);
	if (fd == -1)
		(*err)++;
	else
		close(fd);
	if (ornttn == 'w')
		g->map->tex_west = mlx_load_png(path);
	if (ornttn == 'n')
		g->map->tex_north = mlx_load_png(path);
	if (ornttn == 'e')
		g->map->tex_east = mlx_load_png(path);
	if (ornttn == 's')
		g->map->tex_south = mlx_load_png(path);
	if (*err)
	{
		ft_fprintf(2, RED"Error loading texture in map meta definition: "D);
		ft_fprintf(2, "%s\n", path);
	}
	ft_multifree(NULL, NULL, path, tmp_path);
}


#include "../../include/cub3d.h"

int	check_all_meta(t_game *game)
{
	if (!game->map->tex_west)
		return (0);
	if (!game->map->tex_east)
		return (0);
	if (!game->map->tex_north)
		return (0);
	if (!game->map->tex_south)
		return (0);
	if (!game->map->floor_set)
		return (0);
	if (!game->map->ceiling_set)
		return (0);
	return (1);
}

int	got_meta_line(t_game *game, char *s1, char *s2, size_t n)
{
	if (!ft_strncmp(s1, s2, n))
	{
		if (!ft_strcmp(s2, "NO ") && !game->map->tex_north)
			return (1);
		if (!ft_strcmp(s2, "SO ") && !game->map->tex_south)
			return (1);
		if (!ft_strcmp(s2, "WE ") && !game->map->tex_west)
			return (1);
		if (!ft_strcmp(s2, "EA ") && !game->map->tex_east)
			return (1);
		if (!ft_strcmp(s2, "F ") && !game->map->floor_set)
			return (1);
		if (!ft_strcmp(s2, "C ") && !game->map->ceiling_set)
			return (1);
		ft_fprintf(2, RED"a Meta define is not unique\n"D);
		return (0);
	}
	return (0);
}

void	retreive_meta(char *line, int *err, t_game *game)
{
	if (got_meta_line(game, line, "NO ", 3))
		set_textr_meta(err, line, game, 'n');
	else if (got_meta_line(game, line, "SO ", 3))
		set_textr_meta(err, line, game, 's');
	else if (got_meta_line(game, line, "WE ", 3))
		set_textr_meta(err, line, game, 'w');
	else if (got_meta_line(game, line, "EA ", 3))
		set_textr_meta(err, line, game, 'e');
	else if (got_meta_line(game, line, "F ", 2))
		set_color_meta(err, line, game, 'f');
	else if (got_meta_line(game, line, "C ", 2))
		set_color_meta(err, line, game, 'c');
	else
	{
		if (ft_strlen(line) == ft_strspn(line, MAP_CNT_CHARS))
		{
			ft_fprintf(2, RED"Received Meta Data in wrong format ");
			ft_fprintf(2, "or a mandatory Meta is missing because");
			ft_fprintf(2, " this seems to be map content: \n %s\n"D, line);
		}
		else
			ft_fprintf(2, RED"Received Meta Data in wrong format\n"D);
		(*err)++;
	}
}

void	get_map_meta(int fd, int *err, t_game *game)
{
	int		allfound;
	char	*line;

	allfound = 0;
	line = get_next_line(fd);
	while (line != NULL && !allfound && !(*err))
	{
		if (ft_strcmp(line, "\n"))
		{
			retreive_meta(line, err, game);
			allfound = check_all_meta(game);
		}
		free(line);
		line = NULL;
		if (!allfound)
			line = get_next_line(fd);
	}
	free(line);
	line = NULL;
}


#include "../../include/cub3d.h"

void	trim_map_content(char **splits, t_map_bounds *bounds)
{
	int		i;
	char	*new_line;

	i = bounds->start;
	while (i <= bounds->end)
	{
		new_line = create_new_line(splits[i], bounds);
		if (!new_line)
			return ;
		free(splits[i]);
		splits[i] = new_line;
		i++;
	}
}

int	allocate_map_content(t_map *map)
{
	map->content = ft_calloc(map->height + 1, sizeof(char *));
	if (!map->content)
		return (0);
	return (1);
}

int	copy_map_content_process(t_map *map, char **splits, int start, int i)
{
	map->content[i] = ft_strdup(splits[start + i]);
	if (!map->content[i])
	{
		while (i > 0)
			free(map->content[--i]);
		free(map->content);
		map->content = NULL;
		return (0);
	}
	return (1);
}

int	copy_map_content(t_map *map, char **splits, int start)
{
	int	i;

	i = 0;
	while (i < map->height)
	{
		if (!copy_map_content_process(map, splits, start, i))
			return (0);
		i++;
	}
	map->content[map->height] = NULL;
	return (1);
}

void	parse_map_array(t_map *map, char **splits)
{
	t_map_bounds	bounds;

	find_map_bounds(splits, &bounds.start, &bounds.end);
	if (bounds.start == -1 || bounds.end == -1)
	{
		free_splits(splits);
		return ;
	}
	find_map_width(splits, &bounds);
	trim_map_content(splits, &bounds);
	map->height = bounds.end - bounds.start + 1;
	map->width = bounds.right - bounds.left + 1;
	if (!allocate_map_content(map))
	{
		free_splits(splits);
		return ;
	}
	if (!copy_map_content(map, splits, bounds.start))
	{
		free_splits(splits);
		return ;
	}
	free_splits(splits);
}


#include "../../include/cub3d.h"

size_t	count_lines(char *str)
{
	size_t	count;
	size_t	i;

	count = 1;
	i = 0;
	while (str[i])
	{
		if (str[i] == '\n')
			count++;
		i++;
	}
	return (count);
}

int	alloc_and_cpy_line(char **result, t_splt_ctx *ctx, size_t len)
{
	result[ctx->j] = ft_calloc(len + 1, sizeof(char));
	if (!result[ctx->j])
	{
		free_splits(result);
		return (0);
	}
	ft_strlcpy(result[ctx->j], ctx->start, len + 1);
	return (1);
}

char	**split_lines_init(size_t count)
{
	char	**result;

	result = allocate_result(count);
	if (!result)
		return (NULL);
	return (result);
}

char	**split_lines_process(char **result, t_splt_ctx *ctx)
{
	size_t	len;

	if (ctx->str[ctx->i] == '\n' || ctx->str[ctx->i] == '\0')
	{
		len = &ctx->str[ctx->i] - ctx->start;
		if (!alloc_and_cpy_line(result, ctx, len))
			return (NULL);
		ctx->start = &ctx->str[ctx->i + 1];
		ctx->j++;
	}
	ctx->i++;
	return (result);
}

char	**split_lines(char *str, size_t count)
{
	char		**result;
	t_splt_ctx	ctx;

	result = split_lines_init(count);
	if (!result)
		return (NULL);
	ctx.str = str;
	ctx.count = count;
	ctx.i = 0;
	ctx.j = 0;
	ctx.start = str;
	while (ctx.i <= ft_strlen(str))
	{
		result = split_lines_process(result, &ctx);
		if (!result)
			return (NULL);
	}
	return (result);
}


#include "../../include/cub3d.h"

void	free_splits(char **splits)
{
	int	i;

	i = 0;
	while (splits[i] != NULL)
	{
		free(splits[i]);
		i++;
	}
	free(splits);
}

void	update_map_bounds(char c, t_map_bounds *bounds, int j)
{
	if (c != ' ' && c != '\t')
	{
		if (j < bounds->left)
			bounds->left = j;
		if (j > bounds->right)
			bounds->right = j;
	}
}

void	find_map_width_init(t_map_bounds *bounds)
{
	bounds->left = INT_MAX;
	bounds->right = 0;
}

void	find_map_width_process(char **splits, int i, t_map_bounds *bounds)
{
	int	j;

	j = 0;
	while (splits[i][j])
	{
		update_map_bounds(splits[i][j], bounds, j);
		j++;
	}
}

void	find_map_width(char **splits, t_map_bounds *bounds)
{
	int	i;

	find_map_width_init(bounds);
	i = bounds->start;
	while (i <= bounds->end)
	{
		find_map_width_process(splits, i, bounds);
		i++;
	}
}


#include "../../include/cub3d.h"

char	*create_new_line(char *old_line, t_map_bounds *bounds)
{
	char	*new_line;
	int		j;
	int		new_width;

	new_width = bounds->right - bounds->left + 1;
	new_line = ft_calloc(new_width + 1, sizeof(char));
	if (!new_line)
		return (NULL);
	j = 0;
	while (j < new_width)
	{
		if (bounds->left + j < (int)ft_strlen(old_line))
			new_line[j] = old_line[bounds->left + j];
		else
			new_line[j] = ' ';
		j++;
	}
	new_line[new_width] = '\0';
	return (new_line);
}


#include "../../include/cub3d.h"

char	**allocate_result(size_t count)
{
	char	**result;

	result = (char **)malloc((count + 1) * sizeof(char *));
	if (!result)
		return (NULL);
	result[count] = NULL;
	return (result);
}

char	**allocate_rect_array(int num_rows)
{
	char	**rect_array;

	rect_array = (char **)malloc((num_rows + 1) * sizeof(char *));
	if (rect_array == NULL)
		return (NULL);
	rect_array[num_rows] = NULL;
	return (rect_array);
}

char	**map_split(char *str)
{
	size_t	count;
	char	*trimmed_map;
	char	**result;

	trimmed_map = ft_strtrim(str, "\n");
	count = count_lines(trimmed_map);
	result = split_lines(trimmed_map, count);
	free(trimmed_map);
	return (result);
}


#include "../../include/cub3d.h"

int	is_map_line(char *line)
{
	int	has_wall;

	has_wall = 0;
	while (*line)
	{
		if (*line == '1')
			has_wall = 1;
		if (ft_strchr(MAP_CNT_CHARS, *line) == NULL)
			return (0);
		line++;
	}
	return (has_wall);
}

void	find_map_bounds(char **splits, int *start, int *end)
{
	int	i;

	*start = -1;
	*end = -1;
	i = 0;
	while (splits[i])
	{
		if (is_map_line(splits[i]))
		{
			if (*start == -1)
				*start = i;
			*end = i;
		}
		else if (*start != -1)
			break ;
		i++;
	}
}


#include "../../include/cub3d.h"

void	ft_printmetas(t_map *map)
{
	ft_printf("\nTexture Pointers:\n");
	ft_printf("West: %p\n", (void *)map->tex_west);
	ft_printf("East: %p\n", (void *)map->tex_east);
	ft_printf("North: %p\n", (void *)map->tex_north);
	ft_printf("South: %p\n", (void *)map->tex_south);
	ft_printf("\nColors:\n");
	printf("Floor: 0x%08X\n", map->floor);
	printf("Ceiling: 0x%08X\n", map->ceiling);
	ft_printf("\nFlags:\n");
	ft_printf("Ceiling set: %d\n", map->ceiling_set);
	ft_printf("Floor set: %d\n", map->floor_set);
	ft_printf(G"------------------------------------\n");
	ft_printf("MAP VALID >>> START GAME\n");
	ft_printf("------------------------------------\n\n"D);
}

void	print_map(t_map *map)
{
	int	i;
	int	j;

	i = 0;
	if (!map)
		return ;
	if (map->content)
	{
		while (map->content[i])
		{
			j = 0;
			while (map->content[i][j])
			{
				ft_printf(G"%c"D, map->content[i][j]);
				j++;
			}
			ft_printf("\n");
			i++;
		}
	}
	ft_printmetas(map);
}

void	print_map_error(t_map *map, int ey, int ex)
{
	int	i;
	int	j;

	i = 0;
	if (map->content)
	{
		while (map->content[i])
		{
			j = 0;
			while (map->content[i][j])
			{
				if (i == ey && j == ex)
					ft_fprintf(2, RED"%c"D, map->content[i][j]);
				else
					ft_fprintf(2, B"%c"D, map->content[i][j]);
				j++;
			}
			ft_fprintf(2, "\n");
			i++;
		}
	}
}


#include "../../include/cub3d.h"

int	validate_map(t_game *game, char *filename)
{
	int		fd;
	int		problem;

	problem = 0;
	fd = open(filename, O_RDONLY);
	if (fd < 0)
		return (1);
	get_map_meta(fd, &problem, game);
	get_map_content(fd, &problem, game);
	close(fd);
	if (problem)
		call_exit(game);
	return (0);
}

int	validate_input(int argc, char **argv)
{
	if (argc != 2)
	{
		ft_putstr_fd(2, RED"./cube3d [map.cub]\n"D);
		return (1);
	}
	if (!ft_strendswith(argv[1], ".cub"))
	{
		ft_putstr_fd(2, RED"map must be .cub file\n"D);
		return (1);
	}
	if (access(argv[1], R_OK) != 0)
	{
		ft_putstr_fd(2, RED"cannot read from map file\n"D);
		return (1);
	}
	return (0);
}

void	get_map(t_game *game, int argc, char **argv)
{
	game->map = malloc(sizeof(t_map));
	if (!game->map)
		return ;
	game->map->content = NULL;
	game->map->tex_west = NULL;
	game->map->tex_east = NULL;
	game->map->tex_north = NULL;
	game->map->tex_south = NULL;
	game->map->ceiling = 0;
	game->map->floor = 0;
	game->map->ceiling_set = 0;
	game->map->floor_set = 0;
	game->map->width = 0;
	game->map->height = 0;
	game->map->spawn_x = -1;
	game->map->spawn_y = -1;
	game->map->spawn = '-';
	if (validate_input(argc, argv) > 0)
	{
		call_exit(game);
		return ;
	}
	if (validate_map(game, argv[1]) > 0)
		call_exit(game);
}


#include "../../include/cub3d.h"

/*****************************************/
/*	Calculation to get the len of the ray
	hitting the horizontal grid				*/
/*****************************************/
float	get_len_to_horizontal_wall(t_game *game, t_ray *ray)
{
	float	y;
	float	x;
	float	len_y;
	float	len_x;
	int		direction;

	len_y = CELL;
	len_x = CELL / tan(ray->current_angle);
	y = floor(game->player->y / CELL) * CELL;
	direction = get_h_drctn(ray->current_angle, &y,
			&len_y);
	x = game->player->x + (y - game->player->y)
		/ tan(ray->current_angle);
	if (is_looking_west(ray->current_angle) && len_x > 0)
		len_x *= -1;
	if (!is_looking_west(ray->current_angle) && len_x < 0)
		len_x *= -1;
	while (!is_wall(game, x, y - direction))
	{
		x += len_x;
		y += len_y;
	}
	ray->wall_hit_x = x;
	return (calculate_len(game, x, y));
}

/*****************************************/
/*	Calculation to get the len of the ray
	hitting the vertical grid					*/
/*****************************************/
float	get_len_to_vertical_wall(t_game *game, t_ray *ray)
{
	float	y;
	float	x;
	float	len_y;
	float	len_x;
	int		direction;

	len_x = CELL;
	len_y = CELL * tan(ray->current_angle);
	x = floor(game->player->x / CELL) * CELL;
	direction = get_v_drctn(ray->current_angle, &x,
			&len_x);
	y = game->player->y + (x - game->player->x)
		* tan(ray->current_angle);
	if (is_looking_south(ray->current_angle) && len_y < 0)
		len_y *= -1;
	if (!is_looking_south(ray->current_angle) && len_y > 0)
		len_y *= -1;
	while (!is_wall(game, x - direction, y))
	{
		x += len_x;
		y += len_y;
	}
	ray->wall_hit_y = y;
	return (calculate_len(game, x, y));
}

int	ray_calculation(t_game *game)
{
	t_ray	ray;

	ray.index = 0;
	ray.current_angle = game->player->angle - (((FOV * PI) / 180) / 2);
	while (ray.index < NUM_RAYS)
	{
		ray.current_angle = angle_check(ray.current_angle);
		ray.horizontal_len = get_len_to_horizontal_wall(game, &ray);
		ray.vertical_len = get_len_to_vertical_wall(game, &ray);
		ray.horizontal_len *= 0.4;
		ray.vertical_len *= 0.4;
		ray.len = get_min(ray.vertical_len, ray.horizontal_len);
		rendering_wall(game, ray);
		ray.index++;
		ray.current_angle += (((FOV * PI) / 180) / WINDOW_WIDTH);
	}
	return (0);
}


#include "../../include/cub3d.h"

int	is_looking_right(float angle)
{
	if (angle >= 0 && angle < M_PI_2)
		return (1);
	return (0);
}

int	is_looking_down(float angle)
{
	if (angle >= M_PI_2 && angle < M_PI)
		return (1);
	return (0);
}

int	is_looking_left(float angle)
{
	if (angle >= M_PI && angle < 3 * M_PI_2)
		return (1);
	return (0);
}

int	is_looking_up(float angle)
{
	if (angle >= 3 * M_PI_2 && angle < 2 * M_PI)
		return (1);
	return (0);
}


#include "../../include/cub3d.h"

int	is_looking_north(float angle)
{
	if (angle >= M_PI && angle < (2 * M_PI))
		if (!is_looking_right(angle))
			if (!is_looking_down(angle))
				return (1);
	return (0);
}

int	is_looking_east(float angle)
{
	if (angle >= (M_PI / 2) && angle < (3 * M_PI) / 2)
		if (!is_looking_down(angle))
			if (!is_looking_left(angle))
				return (1);
	return (0);
}

int	is_looking_south(float angle)
{
	if (angle >= 0 && angle < M_PI)
		if (!is_looking_left(angle))
			if (!is_looking_up(angle))
				return (1);
	return (0);
}

int	is_looking_west(float angle)
{
	if (angle >= (M_PI / 2) && angle < (3 * M_PI) / 2)
		if (!is_looking_up(angle))
			if (!is_looking_right(angle))
				return (1);
	return (0);
}


#include "../../include/cub3d.h"

int	is_position_in_map(t_game *game, int pos_y, int pos_x)
{
	if (game->map->content[pos_y]
		&& (pos_x <= (int)ft_strlen(game->map->content[pos_y])))
		return (1);
	return (0);
}

int	is_wall(t_game *game, float xv, float yv)
{
	int	y;
	int	x;

	y = floor(yv / CELL);
	x = floor(xv / CELL);
	if (y >= game->map->height || y < 0)
		return (1);
	if (x >= game->map->width || x < 0)
		return (1);
	if (is_position_in_map(game, y, x))
		if (game->map->content[y][x] == '1')
			return (1);
	return (0);
}

int	get_h_drctn(float current_angle, float *y,
		float *len_y)
{
	if (is_looking_right(current_angle) || is_looking_down(current_angle))
	{
		*y = *y + CELL;
		return (-1);
	}
	*len_y = *len_y * (-1);
	return (1);
}

int	get_v_drctn(float current_angle, float *x,
		float *len_x)
{
	if (is_looking_right(current_angle) || is_looking_up(current_angle))
	{
		*x = *x + CELL;
		return (-1);
	}
	*len_x = *len_x * (-1);
	return (1);
}

float	calculate_len(t_game *game, float x, float y)
{
	float	len_x;
	float	len_y;

	len_x = x - game->player->x;
	len_y = y - game->player->y;
	return (sqrt(pow(len_x, 2) + pow(len_y, 2)));
}


#include "../../include/cub3d.h"

/********************************************************/
/*	Function to check if angle is within radian values	*/
/********************************************************/
float	angle_check(float angle)
{
	if (angle >= 2 * M_PI)
		return (angle - 2 * M_PI);
	else if (angle < 0)
		return (angle + 2 * M_PI);
	else
		return (angle);
}

float	get_min(float a, float b)
{
	if (a <= b)
		return (a);
	else
		return (b);
}


#include "../../include/cub3d.h"

void	draw_ceiling(t_game *game, int index_of_ray, int top)
{
	while (top)
	{
		drawpixel(game->surface, index_of_ray, top, game->map->ceiling);
		top--;
	}
}

void	draw_floor(t_game *game, int index_of_ray, int bottom)
{
	while (bottom < WINDOW_HEIGHT)
	{
		drawpixel(game->surface, index_of_ray, bottom, game->map->floor);
		bottom++;
	}
}

void	rendering_wall(t_game *game, t_ray ray)
{
	float	fcbottom;
	float	fctop;
	float	bottom;
	float	top;
	float	wall_height;

	ray.len = fish_eye_crct(game, ray.len, ray.current_angle);
	wall_height = (CELL / ray.len) * ((WINDOW_HEIGHT / 2) / tan(M_PI_2 / 2));
	top = (WINDOW_HEIGHT / 2) - (wall_height / 2);
	bottom = (WINDOW_HEIGHT / 2) + (wall_height / 2);
	fctop = top;
	fcbottom = bottom;
	calc_wallslice_height(&fctop, &fcbottom);
	draw_ceiling(game, ray.index, fctop);
	draw_floor(game, ray.index, fcbottom);
	draw_wall(game, ray, top, bottom);
}


#include "../../include/cub3d.h"

float	fish_eye_crct(t_game *game, float ray_len, float current_angle)
{
	return (ray_len * cos((current_angle - game->player->angle)));
}

void	calc_wallslice_height(float *top, float *bottom)
{
	if (*bottom > WINDOW_HEIGHT)
		*bottom = WINDOW_HEIGHT;
	if (*top < 0)
		*top = 0;
}

void	drawpixel(mlx_image_t *image, float x, float y, uint32_t color)
{
	if (x >= 0 && x < image->width && y >= 0 && y < image->height)
		mlx_put_pixel(image, (uint32_t)x, (uint32_t)y, color);
}

int	ft_surface(t_game *game)
{
	if (game->surface)
		mlx_delete_image(game->mlx, game->surface);
	game->surface = mlx_new_image(game->mlx, WINDOW_WIDTH, WINDOW_HEIGHT);
	if (!game->surface)
		return (1);
	if (mlx_image_to_window(game->mlx, game->surface, 0, 0) == -1)
		return (1);
	return (0);
}

int	get_rgba_colors_hex(int red, int green, int blue, int alpha)
{
	return (red << 24 | green << 16 | blue << 8 | alpha);
}


#include "../../include/cub3d.h"

char	get_shade(t_ray ray)
{
	if (ray.vertical_len <= ray.horizontal_len)
	{
		if (is_looking_west(ray.current_angle))
			return ('w');
		else
			return ('e');
	}
	else
	{
		if (is_looking_south(ray.current_angle))
			return ('s');
		else
			return ('n');
	}
}

int	get_dr_end(float bottom)
{
	int	draw_end;

	if (bottom > WINDOW_HEIGHT)
		draw_end = WINDOW_HEIGHT;
	else
		draw_end = bottom;
	return (draw_end);
}

uint32_t	apply_shading(uint32_t color, char shade)
{
	uint8_t	r;
	uint8_t	g;
	uint8_t	b;
	uint8_t	a;
	float	factor;

	r = (color >> 24) & 0xFF;
	g = (color >> 16) & 0xFF;
	b = (color >> 8) & 0xFF;
	a = color & 0xFF;
	if (shade == 'n')
		factor = 0.8;
	else if (shade == 'w' || shade == 'e')
		factor = 0.9;
	else
		factor = 1.0;
	r = (uint8_t)(r * factor);
	g = (uint8_t)(g * factor);
	b = (uint8_t)(b * factor);
	return ((r << 24) | (g << 16) | (b << 8) | a);
}

void	draw_wall(t_game *g, t_ray ray, int top, int bottom)
{
	uint32_t		clr;
	mlx_texture_t	*tex;
	double			t_idx;
	int				draw_start;
	int				y;

	tex = get_texture(g, ray);
	if (top < 0)
		draw_start = 0;
	else
		draw_start = top;
	t_idx = (draw_start - top) * get_step_size(g, tex, bottom - top);
	y = draw_start;
	while (y < get_dr_end(bottom))
	{
		t_idx += get_step_size(g, tex, bottom - top);
		clr = get_pxl_clr(tex, get_xpos(g, ray, tex), (int)t_idx % tex->height);
		clr = apply_shading(clr, get_shade(ray));
		mlx_put_pixel(g->surface, ray.index, y, clr);
		y++;
	}
}


#include "../../include/cub3d.h"

mlx_texture_t	*get_texture(t_game *game, t_ray ray)
{
	if (ray.vertical_len <= ray.horizontal_len)
	{
		if (is_looking_west(ray.current_angle))
			return (game->map->tex_west);
		else
			return (game->map->tex_east);
	}
	else
	{
		if (is_looking_south(ray.current_angle))
			return (game->map->tex_south);
		else
			return (game->map->tex_north);
	}
}

double	get_step_size(t_game *game, mlx_texture_t *texture, int height)
{
	if (texture == game->map->tex_north)
		return ((double)game->map->tex_north->height / height);
	else if (texture == game->map->tex_east)
		return ((double)game->map->tex_east->height / height);
	else if (texture == game->map->tex_south)
		return ((double)game->map->tex_south->height / height);
	else
		return ((double)game->map->tex_west->height / height);
}

// Calculate the texture x-coordinate based on the wall hit position
int	get_xpos(t_game *game, t_ray ray, mlx_texture_t *texture)
{
	double	relative_pos;
	int		texture_x;

	if (ray.vertical_len <= ray.horizontal_len)
		relative_pos = fmod(ray.wall_hit_y, CELL);
	else
		relative_pos = fmod(ray.wall_hit_x, CELL);
	texture_x = (int)(relative_pos / CELL * texture->width);
	if (texture == game->map->tex_west || texture == game->map->tex_south)
		texture_x = texture->width - texture_x - 1;
	return (texture_x);
}

int	get_pxl_clr(mlx_texture_t *texture, int x, int y)
{
	unsigned int	i;

	i = (y * texture->width + x) * 4;
	return (get_rgba_colors_hex(texture->pixels[i], texture->pixels[i + 1],
			texture->pixels[i + 2], texture->pixels[i + 3]));
}


#include "../../include/cub3d.h"

void	ft_set_color_minimap_char(mlx_image_t *image, uint32_t color)
{
	uint32_t	x;
	uint32_t	y;

	x = 0;
	y = 0;
	while (x < image->width)
	{
		while (y < image->height)
		{
			mlx_put_pixel(image, x, y, color);
			y++;
		}
		y = 0;
		x++;
	}
}

int	ft_load_textures_minimap(t_game *game)
{
	int	i;

	i = 0;
	game->mouse_locked = true;
	return (i);
}


#include "../../include/cub3d.h"

// int	ft_load_textures_item(t_game *game)
// {
// 	int	i;
// 	int	pos_y;
// 	int	pos_x;

// 	i = 0;
// 	while (i < game->item_total)
// 	{
// 		game->item[i]->texture = mlx_load_png(PATH_ITEM);
// 		if (!game->item[i]->texture)
// 			return (call_exit(game), 0);
// 		game->item[i]->image = mlx_texture_to_image(game->game_window,
// 				game->item[i]->texture);
// 		if (!game->item[i]->image)
// 			return (call_exit(game), 0);
// 		pos_y = game->item[i]->pos->y * PIXEL;
// 		pos_x = game->item[i]->pos->x * PIXEL;
// 		if (mlx_image_to_window(game->game_window, game->item[i]->image, pos_x,
// 				pos_y) == -1)
// 			return (call_exit(game), 0);
// 		mlx_delete_texture(game->item[i]->texture);
// 		i++;
// 	}
// 	return (0);
// }


#include "../../include/cub3d.h"

void	call_exit_map_textrs(t_game *game)
{
	if (game->map->tex_west)
		mlx_delete_texture(game->map->tex_west);
	if (game->map->tex_east)
		mlx_delete_texture(game->map->tex_east);
	if (game->map->tex_north)
		mlx_delete_texture(game->map->tex_north);
	if (game->map->tex_south)
		mlx_delete_texture(game->map->tex_south);
	game->map->tex_west = NULL;
	game->map->tex_east = NULL;
	game->map->tex_north = NULL;
	game->map->tex_south = NULL;
}

void	call_exit_player(t_player *player)
{
	if (player)
		free(player);
}

void	call_exit_map(t_game *game)
{
	int	i;

	i = 0;
	if (game)
	{
		if (game->map)
		{
			if (game->map->content)
			{
				while (game->map->content[i])
				{
					free(game->map->content[i]);
					game->map->content[i] = NULL;
					i++;
				}
				free(game->map->content);
				game->map->content = NULL;
			}
			call_exit_map_textrs(game);
			free(game->map);
			game->map = NULL;
		}
	}
}

void	call_exit(t_game *game)
{
	if (game)
	{
		call_exit_player(game->player);
		call_exit_map(game);
	}
}


#include "../../include/cub3d.h"

void	ft_initialize_player(t_game *game)
{
	game->player = malloc(sizeof(t_player));
	if (!game->player)
		return ;
	game->player->x = game->map->spawn_x * CELL + (CELL / 2);
	game->player->y = game->map->spawn_y * CELL + (CELL / 2);
	if (game->map->spawn == 'E')
		game->player->angle = 0;
	else if (game->map->spawn == 'S')
		game->player->angle = M_PI / 2;
	else if (game->map->spawn == 'W')
		game->player->angle = M_PI;
	else if (game->map->spawn == 'N')
		game->player->angle = 3 * M_PI / 2;
}

mlx_t	*ft_init_window(t_game *game)
{
	game->mlx = mlx_init(WINDOW_WIDTH, WINDOW_HEIGHT,
			NAME_WINDOW, true);
	if (!game->mlx)
		return (NULL);
	return (game->mlx);
}

void	ft_initialize_game(t_game	*game)
{
	game->map = NULL;
	game->mlx = NULL;
	game->surface = NULL;
	game->key_states.w_pressed = false;
	game->key_states.s_pressed = false;
	game->key_states.a_pressed = false;
	game->key_states.d_pressed = false;
	game->key_states.left_pressed = false;
	game->key_states.right_pressed = false;
}

void	ft_initialize(t_game *game, int argc, char **argv)
{
	ft_initialize_game(game);
	get_map(game, argc, argv);
	if (!game->map)
	{
		call_exit(game);
		return ;
	}
	print_map(game->map);
	ft_initialize_player(game);
}


#include "../include/cub3d.h"

void	check_collision(t_game *game, float *new_x, float *new_y)
{
	int		radius;
	float	old_x;
	float	old_y;

	radius = (PLAYER_SIZE / 2) + 1;
	old_x = game->player->x;
	old_y = game->player->y;
	if (get_cellchar(game, *new_x - radius, old_y - radius) == '1'
		|| get_cellchar(game, *new_x + radius, old_y - radius) == '1'
		|| get_cellchar(game, *new_x - radius, old_y + radius) == '1'
		|| get_cellchar(game, *new_x + radius, old_y + radius) == '1')
	{
		*new_x = old_x;
	}
	if (get_cellchar(game, old_x - radius, *new_y - radius) == '1'
		|| get_cellchar(game, old_x + radius, *new_y - radius) == '1'
		|| get_cellchar(game, old_x - radius, *new_y + radius) == '1'
		|| get_cellchar(game, old_x + radius, *new_y + radius) == '1')
	{
		*new_y = old_y;
	}
}

char	get_cellchar(t_game *game, int x, int y)
{
	int	cell_x;
	int	cell_y;

	cell_x = x / CELL;
	cell_y = y / CELL;
	return (game->map->content[cell_y][cell_x]);
}

